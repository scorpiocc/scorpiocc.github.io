<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F05%2F19%2FJava%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%2FSpring%20AOP%20%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[title: Hexo的Next主题侧边栏自定义修改date: 2017-05-19tags: [Spring, AOP]categories: Spring-AOP AOPAOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP核心概念1、横切关注点 对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点 2、切面（aspect） 类是对物体特征的抽象，切面就是对横切关注点的抽象 3、连接点（joinpoint） 被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器 4、切入点（pointcut） 对连接点进行拦截的定义 5、通知（advice） 所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类 6、目标对象 代理的目标对象 7、织入（weave） 将切面应用到目标对象并导致代理对象创建的过程 8、引入（introduction） 在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段 Spring对AOP的支持Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为： 1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了 2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分： 1、定义普通业务组件 2、定义切入点，一个切入点可能横切多个业务组件 3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作 所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：代理对象的方法=增强处理+被代理对象的方法。 下面给出一个Spring AOP的.xml文件模板，名字叫做aop.xml，之后的内容都在aop.xml上进行扩展： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;&lt;/beans&gt; 基于Spring的AOP简单实现注意一下，在讲解之前，说明一点：使用Spring AOP，要成功运行起代码，只用Spring提供给开发者的jar包是不够的，请额外上网下载两个jar包： 1、aopalliance.jar 2、aspectjweaver.jar 如果是maven项目的话就要在pom.xml中加: 1、spring-aop 2、spring-aspects 开始讲解用Spring AOP的XML实现方式，先定义一个接口： 12345public interface HelloWorld&#123; void printHelloWorld(); void doPrint();&#125; 定义两个接口实现类：12345678910111213public class HelloWorldImpl1 implements HelloWorld&#123; public void printHelloWorld() &#123; System.out.println(&quot;Enter HelloWorldImpl1.printHelloWorld()&quot;); &#125; public void doPrint() &#123; System.out.println(&quot;Enter HelloWorldImpl1.doPrint()&quot;); return ; &#125;&#125; 12345678910111213public class HelloWorldImpl2 implements HelloWorld&#123; public void printHelloWorld() &#123; System.out.println(&quot;Enter HelloWorldImpl2.printHelloWorld()&quot;); &#125; public void doPrint() &#123; System.out.println(&quot;Enter HelloWorldImpl2.doPrint()&quot;); return ; &#125;&#125; 横切关注点，这里是打印时间：1234567public class TimeHandler&#123; public void printTime() &#123; System.out.println(&quot;CurrentTime = &quot; + System.currentTimeMillis()); &#125;&#125; 有这三个类就可以实现一个简单的Spring AOP了，看一下aop.xml的配置：12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt; &lt;bean id=&quot;helloWorldImpl1&quot; class=&quot;com.xrq.aop.HelloWorldImpl1&quot; /&gt; &lt;bean id=&quot;helloWorldImpl2&quot; class=&quot;com.xrq.aop.HelloWorldImpl2&quot; /&gt; &lt;bean id=&quot;timeHandler&quot; class=&quot;com.xrq.aop.TimeHandler&quot; /&gt; &lt;aop:config&gt; &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot;&gt; &lt;aop:pointcut id=&quot;addAllMethod&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.*(..))&quot; /&gt; &lt;aop:before method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt; &lt;aop:after method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 写一个main函数调用一下：12345678910111213141516public static void main(String[] args)&#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;aop.xml&quot;); HelloWorld hw1 = (HelloWorld)ctx.getBean(&quot;helloWorldImpl1&quot;); HelloWorld hw2 = (HelloWorld)ctx.getBean(&quot;helloWorldImpl2&quot;); hw1.printHelloWorld(); System.out.println(); hw1.doPrint(); System.out.println(); hw2.printHelloWorld(); System.out.println(); hw2.doPrint();&#125; 运行结果为：123456789101112131415CurrentTime = 1446129611993Enter HelloWorldImpl1.printHelloWorld()CurrentTime = 1446129611993CurrentTime = 1446129611994Enter HelloWorldImpl1.doPrint()CurrentTime = 1446129611994CurrentTime = 1446129611994Enter HelloWorldImpl2.printHelloWorld()CurrentTime = 1446129611994CurrentTime = 1446129611994Enter HelloWorldImpl2.doPrint()CurrentTime = 1446129611994 看到给HelloWorld接口的两个实现类的所有方法都加上了代理，代理内容就是打印时间 基于Spring的AOP使用其他细节1、增加一个横切关注点，打印日志，Java类为：123456789101112public class LogHandler&#123; public void LogBefore() &#123; System.out.println(&quot;Log before method&quot;); &#125; public void LogAfter() &#123; System.out.println(&quot;Log after method&quot;); &#125;&#125; aop.xml配置为：12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt; &lt;bean id=&quot;helloWorldImpl1&quot; class=&quot;com.xrq.aop.HelloWorldImpl1&quot; /&gt; &lt;bean id=&quot;helloWorldImpl2&quot; class=&quot;com.xrq.aop.HelloWorldImpl2&quot; /&gt; &lt;bean id=&quot;timeHandler&quot; class=&quot;com.xrq.aop.TimeHandler&quot; /&gt; &lt;bean id=&quot;logHandler&quot; class=&quot;com.xrq.aop.LogHandler&quot; /&gt; &lt;aop:config&gt; &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot; order=&quot;1&quot;&gt; &lt;aop:pointcut id=&quot;addTime&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.*(..))&quot; /&gt; &lt;aop:before method=&quot;printTime&quot; pointcut-ref=&quot;addTime&quot; /&gt; &lt;aop:after method=&quot;printTime&quot; pointcut-ref=&quot;addTime&quot; /&gt; &lt;/aop:aspect&gt; &lt;aop:aspect id=&quot;log&quot; ref=&quot;logHandler&quot; order=&quot;2&quot;&gt; &lt;aop:pointcut id=&quot;printLog&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.*(..))&quot; /&gt; &lt;aop:before method=&quot;LogBefore&quot; pointcut-ref=&quot;printLog&quot; /&gt; &lt;aop:after method=&quot;LogAfter&quot; pointcut-ref=&quot;printLog&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试类不变，打印结果为：1234567891011121314151617181920212223CurrentTime = 1446130273734Log before methodEnter HelloWorldImpl1.printHelloWorld()Log after methodCurrentTime = 1446130273735CurrentTime = 1446130273736Log before methodEnter HelloWorldImpl1.doPrint()Log after methodCurrentTime = 1446130273736CurrentTime = 1446130273736Log before methodEnter HelloWorldImpl2.printHelloWorld()Log after methodCurrentTime = 1446130273736CurrentTime = 1446130273737Log before methodEnter HelloWorldImpl2.doPrint()Log after methodCurrentTime = 1446130273737 要想让logHandler在timeHandler前使用有两个办法： （1）aspect里面有一个order属性，order属性的数字就是横切关注点的顺序 （2）把logHandler定义在timeHandler前面，Spring默认以aspect的定义顺序作为织入顺序 2、我只想织入接口中的某些方法 修改一下pointcut的expression就好了：12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt; &lt;bean id=&quot;helloWorldImpl1&quot; class=&quot;com.xrq.aop.HelloWorldImpl1&quot; /&gt; &lt;bean id=&quot;helloWorldImpl2&quot; class=&quot;com.xrq.aop.HelloWorldImpl2&quot; /&gt; &lt;bean id=&quot;timeHandler&quot; class=&quot;com.xrq.aop.TimeHandler&quot; /&gt; &lt;bean id=&quot;logHandler&quot; class=&quot;com.xrq.aop.LogHandler&quot; /&gt; &lt;aop:config&gt; &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot; order=&quot;1&quot;&gt; &lt;aop:pointcut id=&quot;addTime&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.print*(..))&quot; /&gt; &lt;aop:before method=&quot;printTime&quot; pointcut-ref=&quot;addTime&quot; /&gt; &lt;aop:after method=&quot;printTime&quot; pointcut-ref=&quot;addTime&quot; /&gt; &lt;/aop:aspect&gt; &lt;aop:aspect id=&quot;log&quot; ref=&quot;logHandler&quot; order=&quot;2&quot;&gt; &lt;aop:pointcut id=&quot;printLog&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.do*(..))&quot; /&gt; &lt;aop:before method=&quot;LogBefore&quot; pointcut-ref=&quot;printLog&quot; /&gt; &lt;aop:after method=&quot;LogAfter&quot; pointcut-ref=&quot;printLog&quot; /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 可以看到expression字段，表示timeHandler只会织入HelloWorld接口print开头的方法，logHandler只会织入HelloWorld接口do开头的方法. 3、强制使用CGLIB生成代理 前面说过Spring使用动态代理或是CGLIB生成代理是有规则的，高版本的Spring会自动选择是使用动态代理还是CGLIB生成代理内容，当然我们也可以强制使用CGLIB生成代理，那就是里面有一个”proxy-target-class”属性，这个属性值如果被设置为true，那么基于类的代理将起作用，如果proxy-target-class被设置为false或者这个属性被省略，那么基于接口的代理将起作用 原理区别：java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。1231、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换 原文地址:点我]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo的Next主题侧边栏自定义修改]]></title>
    <url>%2F2017%2F05%2F17%2FHexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%2FHexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E4%BE%A7%E8%BE%B9%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[Next主题的强大我就不多说了。侧边栏的标题和网站title标题相同，导致不能自定义。然后我就想着两者能不能分开，本文仅仅探讨个人想法。 如图所示。原版左边2个框是全部获取的title值。但是如何自定义获取呢。就要改源码。 首先右击做自己的太阳举例点击检查，查看源码发现div标签和class命名 然后我们就是根据这个字符去主题下搜索。windows是默认只搜索文件名，所以要设置一下，打开计算机，选择工具，文件夹选项。 搜索完然后我们查找到在themes\next\layout\_partials\header.swig文件。 修改成我们想要的字段，当然我们也可以新建字段，自定义内容。目前本人博客主题是Pisces主题。如图是我修改后的样子。 修改原理都一样，剩下来的都请大家自己探寻把。]]></content>
      <categories>
        <category>Hexo 博客教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合体系总结]]></title>
    <url>%2F2017%2F05%2F05%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F%E3%80%90Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%91Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、Collection(单列集合)List 有序 可重复123ArrayList 底层是数组 查找快，增删慢 线程不安全，效率高LinkedList 底层是链表 查找慢，增删快Vector 底层是数组 查找快，增删慢 线程安全，效率低 Set 无序 不可重复1234567891011HashSet 底层是哈希表 如何保证元素的唯一性 重写元素的hashcode和equals方法 hashcode相同 判断equals方法 返回true 不填加 返回false 添加 hashcode不相同 直接添加 TreeSet 底层是二叉树 如何保证元素的唯一性和排序 1、自然排序(元素具备比较特性) ----实现Comparable接口 2、使用排序器(集合具备比较特性) ---- 实现Comparator接口 二、Map(双列集合) 数据结构只针对键有效1234567891011HashMap 底层是哈希表 如何保证键的唯一性 重写元素的hashcode和equals方法 hashcode相同 判断equals方法 返回true 不填加 返回false 添加 hashcode不相同 直接添加 TreeMap 底层是二叉树 如何保证键的唯一性和排序 1、自然排序(元素具备比较特性) ----实现Comparable接口 2、使用排序器(集合具备比较特性) ---- 实现Comparator接口 2、功能12345678Collection add(Object obj) remove(Object obj) contains(obj) size() iterator() List add(int index,Object obj) remove(int index) get(index) setSet Map put(key,value) remove(key) get(key) containsValue(value) containsKey(key) get(key) keySet() values() entrySet() 3、遍历12345678List 1、迭代器 使用迭代器遍历集合时，不能通过集合对象去修改集合元素 2、for循环 3、增强for循环 仅仅是遍历集合，任选一种， 如果要对集合元素进行操作，使用后面两种 跟集合索引相关的操作，使用for循环 123Set 1、迭代器 2、增强for循环 123Map 1、获取键集合，根据键找值 2、获取键值对集合，根据键值对对象获取键和值 4、怎么选择先看有没有对应关系(是否需要键值对)123456789101112有 Map 是否需要对键排序 需要 TreeMap 不需要 HashMap 没有 Collection 是否要求元素唯一 是 Set 不是 List 是否对元素进行排序 增删多，查找少 LinkedList 是 TreeSet 增删少，查找多 ArrayList或者Vector 不是 HashSet 如果线程安全 Vector 不需要保证线程安全 ArrayList]]></content>
      <categories>
        <category>Java 基础知识</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven警告解决:Using platform encoding （UTF-8 actually）]]></title>
    <url>%2F2017%2F05%2F04%2FJava%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%2FMaven%E8%AD%A6%E5%91%8A%E8%A7%A3%E5%86%B3Using%20platform%20encoding%20(UTF-8%20actually)%2F</url>
    <content type="text"><![CDATA[执行Maven Install打包的时候，提示以下警告信息：1[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent! 解决方法：打开项目属性》Resources，按下图修改。 保存后重新执行Maven Install 发现警告依然存在，原来是理解错误错误了，应该修改Maven的配置文件中关于编码的配置 1&lt;encoding&gt;utf-8&lt;/encoding&gt;： 完整示例：pom.xml 12345678910&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt;&lt;/plugin&gt; 如果还是存在警告，则需要在中添加标签：12345&lt;properties&gt; &lt;project.build.sourceEncoding&gt; UTF-8 &lt;/project.build.sourceEncoding&gt;&lt;/properties&gt; 最终 Maven Install 警告就消失了。 本文作者： Scorpip_cc 本文链接： 原文博客地址 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Java 报错解决</category>
      </categories>
      <tags>
        <tag>Java后台开发</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
</search>