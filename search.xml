<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA 对象序列化——Serializable]]></title>
    <url>%2F2017%2F06%2F12%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F%E3%80%90Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%91JAVA%20%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E2%80%94%E2%80%94Serializable%2F</url>
    <content type="text"><![CDATA[Java的对象序列化是指将那些实现了Serializable接口的对象转换成一个字符序列，并能够在以后将这个字节序列完全恢复为原来的对象。这一过程甚至可通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异。 只要对象实现了Serializable接口（记住，这个接口只是一个标记接口，不包含任何的方法 如果我们想要序列化一个对象，首先要创建某些OutputStream(如FileOutputStream、ByteArrayOutputStream等)，然后将这些OutputStream封装在一个ObjectOutputStream中。这时候，只需要调用writeObject()方法就可以将对象序列化，并将其发送给OutputStream（记住：对象的序列化是基于字节的，不能使用Reader和Writer等基于字符的层次结构）。而反序列的过程（即将一个序列还原成为一个对象），需要将一个InputStream(如FileInputstream、ByteArrayInputStream等)封装在ObjectInputStream内，然后调用readObject()即可。 对象序列化过程不仅仅保存单个对象，还能追踪对象内所包含的所有引用，并保存那些对象（这些对象也需实现了Serializable接口）。下面这段代码演示了此过程： 1234567891011121314151617package test.serializable;/** *只是一个简单的类，用于测试序列化 */import java.io.Serializable;public class Data implements Serializable &#123; private static final long serialVersionUID = 7247714666080613254L; public int n; public Data(int n) &#123; this.n = n; &#125; public String toString()&#123; return Integer.toString(n); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package test.serializable;import java.io.Serializable;import java.util.Random;/** * * @author chenfei * * 用于测试序列化，每个对象Worm对象都与worm中的下一段链接， * 同时又有属于不同类（Data）的对象引用数组链接 */public class Worm implements Serializable &#123; private static final long serialVersionUID = 5468335797443850679L; private Data[] d = &#123; new Data(random.nextInt(10)), new Data(random.nextInt(10)), new Data(random.nextInt(10)) &#125;; private static Random random = new Random(47); private Worm next; private char c; public Worm(int i , char x) &#123; System.out.println("Worm constructor:" +i); c = x; if(--i &gt; 0) &#123; next = new Worm(i , (char)(x+1)); &#125; &#125; public Worm() &#123; System.out.println("Default constructor!"); &#125; public String toString() &#123; StringBuilder sb = new StringBuilder(":"); sb.append(c); sb.append("("); for(Data data : d) &#123; sb.append(data); &#125; sb.append(")"); if(next!=null) &#123; sb.append(next); &#125; return sb.toString(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package test.serializable;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class SerializableTest &#123; public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123; Worm w = new Worm(6 ,'a'); System.out.println("序列化操纵之前"); System.out.println("w="+w); //序列化操作1--FileOutputStream ObjectOutputStream oos1 = new ObjectOutputStream(new FileOutputStream("worm.out")); oos1.writeObject("Worm storage By FileOutputStream "); oos1.writeObject(w);//必须所有引用的对象都实现序列化（本例终究是Data这个类） //否则抛出有java.io.NotSerializableException:这个异常 oos1.close(); //反序列化操作1---FileInputStream ObjectInputStream ois1 = new ObjectInputStream(new FileInputStream("worm.out")); String s1 = (String)ois1.readObject(); Worm w1 = (Worm)ois1.readObject(); ois1.close(); System.out.println("反序列化操作1之后"); System.out.println(s1); System.out.println("w1:"+w1); //序列化操作2--ByteArrayOutputStream ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream(); ObjectOutputStream oos2 = new ObjectOutputStream(byteOutStream); oos2.writeObject("Worm storage By ByteOutputStream "); oos2.writeObject(w); oos2.flush(); //反序列操作2--ByteArrayInputStream ByteArrayInputStream byteInStream = new ByteArrayInputStream(byteOutStream.toByteArray()); ObjectInputStream ois2 = new ObjectInputStream(byteInStream); String s2 = (String)ois2.readObject(); Worm w2 = (Worm)ois2.readObject(); ois2.close(); System.out.println("反序列化操作2之后"); System.out.println(s2); System.out.println("w2:"+w2); &#125;&#125; 运行结果如下：1234567891011121314Worm constructor:6Worm constructor:5Worm constructor:4Worm constructor:3Worm constructor:2Worm constructor:1序列化操纵之前w=:a(853):b(119):c(802):d(788):e(199):f(881)反序列化操作1之后Worm storage By FileOutputStream w1::a(853):b(119):c(802):d(788):e(199):f(881)反序列化操作2之后Worm storage By ByteOutputStream w2::a(853):b(119):c(802):d(788):e(199):f(881) 思考：1）反序列化后的对象，需要调用构造函数重新构造吗？答案：不需要。对于Serializable对象，对象完全以它存储的二进制位作为基础来构造，而不调用构造器 请看下面这段代码12345678910111213141516171819202122package test.serializable;import java.io.Serializable;import java.util.Date;/** * * @author chenfei * * 用于测试序列化时的deep copy * */public class House implements Serializable &#123; private static final long serialVersionUID = -6091530420906090649L; private Date date = new Date(); //记录当前的时间 public String toString() &#123; return "House:" + super.toString() + ".Create Time is:" + date; &#125;&#125; 12345678910111213141516171819202122package test.serializable;import java.io.Serializable;public class Animal implements Serializable &#123; private static final long serialVersionUID = -213221189192962074L; private String name; private House house; public Animal(String name , House house) &#123; this.name = name; this.house = house; System.out.println("调用了构造器"); &#125; public String toString() &#123; return name + "[" +super.toString() + "']" + house; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package test.serializable;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class Myworld &#123; /** * @param args * @throws IOException * @throws ClassNotFoundException */public static void main(String[] args) throws IOException, ClassNotFoundException &#123; House house = new House(); System.out.println("序列化前"); Animal animal = new Animal("test",house); ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(out); oos.writeObject(animal); oos.flush(); oos.close(); System.out.println("反序列化后"); ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray()); ObjectInputStream ois = new ObjectInputStream(in); Animal animal1 = (Animal)ois.readObject(); ois.close(); &#125;&#125; 运行结果如下所示：123序列化前调用了构造器反序列化后 从上面的结果中可以看到，在序列化前，当我们使用Animal animal = new Animal(“test”,house);时，调用了Animal的构造器（打印了输出语句），但是反序列后并没有再打印任何语句，说明并没有调用构造器。 2）序列前的对象与序列化后的对象是什么关系？是(“==”还是equal？是浅复制还是深复制？)答案：深复制，反序列化还原后的对象地址与原来的的地址不同。 我们还是看上面思考1）中给出的代码， 前两个类不变化，修改第三个类（MyWorld.java）的部分代码，修改后的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package test.serializable;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class Myworld &#123; /** * @param args * @throws IOException * @throws ClassNotFoundException */ public static void main(String[] args) throws IOException, ClassNotFoundException &#123; House house = new House(); System.out.println("序列化前"); Animal animal = new Animal("test",house); System.out.println(animal); ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(out); oos.writeObject(animal); oos.writeObject(animal);//在写一次，看对象是否是一样， oos.flush(); oos.close(); ByteArrayOutputStream out2 = new ByteArrayOutputStream();//换一个输出流 ObjectOutputStream oos2 = new ObjectOutputStream(out2); oos2.writeObject(animal); oos2.flush(); oos2.close(); System.out.println("反序列化后"); ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray()); ObjectInputStream ois = new ObjectInputStream(in); Animal animal1 = (Animal)ois.readObject(); Animal animal2 = (Animal)ois.readObject(); ois.close(); ByteArrayInputStream in2 = new ByteArrayInputStream(out2.toByteArray()); ObjectInputStream ois2 = new ObjectInputStream(in2); Animal animal3 = (Animal)ois2.readObject(); ois2.close(); System.out.println("out流：" +animal1); System.out.println("out流：" +animal2); System.out.println("out2流：" +animal3); System.out.println("测试序列化前后的对象 == ："+ (animal==animal1)); System.out.println("测试序列化后同一流的对象："+ (animal1 == animal2)); System.out.println("测试序列化后不同流的对象==:" + (animal1==animal3)); &#125;&#125; 运行结果如下：123456789101112序列化前调用了构造器test[test.serializable.Animal@bb7465']House:test.serializable.House@d6c16c.Create Time is:Sat Apr 06 00:11:30 CST 2013反序列化后out流：test[test.serializable.Animal@4f80d6']House:test.serializable.House@193722c.Create Time is:Sat Apr 06 00:11:30 CST 2013out流：test[test.serializable.Animal@4f80d6']House:test.serializable.House@193722c.Create Time is:Sat Apr 06 00:11:30 CST 2013（与上面的相同）out2流：test[test.serializable.Animal@12cc95d']House:test.serializable.House@157fb52.Create Time is:Sat Apr 06 00:11:30 CST 2013（与上面只是值相同，但是地址不一样。）测试序列化前后的对象 == ：false测试序列化后同一流的对象：true测试序列化后不同流的对象==:false 从结果可以看到 序列化前后对象的地址不同了，但是内容是一样的，而且对象中包含的引用也相同。换句话说，通过序列化操作, 我们可以实现对任何可Serializable对象的”深度复制（deep copy） ——这意味着我们复制的是整个对象网，而不仅仅是基本对象及其引用。对于同一流的对象，他们地址是相同，说明他们是同一个对象，但是与其他流的对象地址却不相同。也就说，只要将对象序列化到单一流中，就可以恢复出与我们写出时一样的对象网，而且只要在同一流中，对象都是同一个。 补充： serialVersionUID 的作用？ 在Java中，软件的兼容性是一个大问题，尤其在使用到对象串行性的时候，那么在某一个对象已经被串行化了，可是这个对象又被修改后重新部署了，那么在这种情况下， 用老软件来读取新文件格式虽然不是什么难事，但是有可能丢失一些信息。 serialVersionUID来解决这些问题，新增的serialVersionUID必须定义成下面这种形式：static final long serialVersionUID=-2805284943658356093L;。其中数字后面加上的L表示这是一个long值。 通过这种方式来解决不同的版本之间的串行话问题。 Java串行化机制定义的文件格式似乎很脆弱，只要稍微改动一下类的定义，原来保存的对象就可能无法读取。例如，下面是一个简单的类定义： 123456789101112public class Save implements Serializable&#123;String name;public void save() throws IOException&#123;FileOutputStream f = new FileOutputStream("foo");ObjectOutputStream oos = new ObjectOutputStream(f);oos.writeObject(this);oos.close();&#125;&#125; 如果在这个类定义中增加一个域，例如final int val = 7;，再来读取原来保存的对象，就会出现下面的异常： java.io.InvalidClassException: Save; local class incompatible: stream classdesc serialVersionUID = -2805284943658356093, local class serialVersionUID = 3419534311899376629 上例异常信息中的数字串表示类定义里各种属性的编码值： 类的名字（Save）。 域的名字（name）。 方法的名字（Save）。 已实现的接口（Serializable）。 改动上述任意一项内容（无论是增加或删除），都会引起编码值变化，从而引起类似的异常警报。这个数字序列称为“串行化版本统一标识符”（serial version universal identifier），简称UID。解决这个问题的办法是在类里面新增一个域serialVersionUID，强制类仍旧使用原来的UID。新增的域必须是： static：该域定义的属性作用于整个类，而非特定的对象。 final：保证代码运行期间该域不会被修改。 long：它是一个64位的数值。 也就是说，新增的serialVersionUID必须定义成下面这种形式：static final long serialVersionUID=-2805284943658356093L;。其中数字后面加上的L表示这是一个long值。 当然，改动之后的类不一定能够和原来的对象兼容。例如，如果把一个域的定义从String改成了int，执行逆-串行化操作时系统就不知道如何处理该值，显示出错误信息：java.io.InvalidClassException: Save; incompatible types for field name。 serialVersionUID 的作用介绍详解:点此跳转原文地址：点此跳转]]></content>
      <categories>
        <category>Java 基础知识</category>
      </categories>
      <tags>
        <tag>对象序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP 面向切面编程详解]]></title>
    <url>%2F2017%2F05%2F19%2FJava%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%2FSpring%20AOP%20%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[AOPAOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP核心概念1、横切关注点 对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点 2、切面（aspect） 类是对物体特征的抽象，切面就是对横切关注点的抽象 3、连接点（joinpoint） 被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器 4、切入点（pointcut） 对连接点进行拦截的定义 5、通知（advice） 所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类 6、目标对象 代理的目标对象 7、织入（weave） 将切面应用到目标对象并导致代理对象创建的过程 8、引入（introduction） 在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段 Spring对AOP的支持Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为： 1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了 2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分： 1、定义普通业务组件 2、定义切入点，一个切入点可能横切多个业务组件 3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作 所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：代理对象的方法=增强处理+被代理对象的方法。 下面给出一个Spring AOP的.xml文件模板，名字叫做aop.xml，之后的内容都在aop.xml上进行扩展： 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"&gt;&lt;/beans&gt; 基于Spring的AOP简单实现注意一下，在讲解之前，说明一点：使用Spring AOP，要成功运行起代码，只用Spring提供给开发者的jar包是不够的，请额外上网下载两个jar包： 1、aopalliance.jar 2、aspectjweaver.jar 如果是maven项目的话就要在pom.xml中加: 1、spring-aop 2、spring-aspects 开始讲解用Spring AOP的XML实现方式，先定义一个接口： 12345public interface HelloWorld&#123; void printHelloWorld(); void doPrint();&#125; 定义两个接口实现类：12345678910111213public class HelloWorldImpl1 implements HelloWorld&#123; public void printHelloWorld() &#123; System.out.println("Enter HelloWorldImpl1.printHelloWorld()"); &#125; public void doPrint() &#123; System.out.println("Enter HelloWorldImpl1.doPrint()"); return ; &#125;&#125; 12345678910111213public class HelloWorldImpl2 implements HelloWorld&#123; public void printHelloWorld() &#123; System.out.println("Enter HelloWorldImpl2.printHelloWorld()"); &#125; public void doPrint() &#123; System.out.println("Enter HelloWorldImpl2.doPrint()"); return ; &#125;&#125; 横切关注点，这里是打印时间：1234567public class TimeHandler&#123; public void printTime() &#123; System.out.println("CurrentTime = " + System.currentTimeMillis()); &#125;&#125; 有这三个类就可以实现一个简单的Spring AOP了，看一下aop.xml的配置：12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"&gt; &lt;bean id="helloWorldImpl1" class="com.xrq.aop.HelloWorldImpl1" /&gt; &lt;bean id="helloWorldImpl2" class="com.xrq.aop.HelloWorldImpl2" /&gt; &lt;bean id="timeHandler" class="com.xrq.aop.TimeHandler" /&gt; &lt;aop:config&gt; &lt;aop:aspect id="time" ref="timeHandler"&gt; &lt;aop:pointcut id="addAllMethod" expression="execution(* com.xrq.aop.HelloWorld.*(..))" /&gt; &lt;aop:before method="printTime" pointcut-ref="addAllMethod" /&gt; &lt;aop:after method="printTime" pointcut-ref="addAllMethod" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 写一个main函数调用一下：12345678910111213141516public static void main(String[] args)&#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("aop.xml"); HelloWorld hw1 = (HelloWorld)ctx.getBean("helloWorldImpl1"); HelloWorld hw2 = (HelloWorld)ctx.getBean("helloWorldImpl2"); hw1.printHelloWorld(); System.out.println(); hw1.doPrint(); System.out.println(); hw2.printHelloWorld(); System.out.println(); hw2.doPrint();&#125; 运行结果为：123456789101112131415CurrentTime = 1446129611993Enter HelloWorldImpl1.printHelloWorld()CurrentTime = 1446129611993CurrentTime = 1446129611994Enter HelloWorldImpl1.doPrint()CurrentTime = 1446129611994CurrentTime = 1446129611994Enter HelloWorldImpl2.printHelloWorld()CurrentTime = 1446129611994CurrentTime = 1446129611994Enter HelloWorldImpl2.doPrint()CurrentTime = 1446129611994 看到给HelloWorld接口的两个实现类的所有方法都加上了代理，代理内容就是打印时间 基于Spring的AOP使用其他细节1、增加一个横切关注点，打印日志，Java类为：123456789101112public class LogHandler&#123; public void LogBefore() &#123; System.out.println("Log before method"); &#125; public void LogAfter() &#123; System.out.println("Log after method"); &#125;&#125; aop.xml配置为：12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"&gt; &lt;bean id="helloWorldImpl1" class="com.xrq.aop.HelloWorldImpl1" /&gt; &lt;bean id="helloWorldImpl2" class="com.xrq.aop.HelloWorldImpl2" /&gt; &lt;bean id="timeHandler" class="com.xrq.aop.TimeHandler" /&gt; &lt;bean id="logHandler" class="com.xrq.aop.LogHandler" /&gt; &lt;aop:config&gt; &lt;aop:aspect id="time" ref="timeHandler" order="1"&gt; &lt;aop:pointcut id="addTime" expression="execution(* com.xrq.aop.HelloWorld.*(..))" /&gt; &lt;aop:before method="printTime" pointcut-ref="addTime" /&gt; &lt;aop:after method="printTime" pointcut-ref="addTime" /&gt; &lt;/aop:aspect&gt; &lt;aop:aspect id="log" ref="logHandler" order="2"&gt; &lt;aop:pointcut id="printLog" expression="execution(* com.xrq.aop.HelloWorld.*(..))" /&gt; &lt;aop:before method="LogBefore" pointcut-ref="printLog" /&gt; &lt;aop:after method="LogAfter" pointcut-ref="printLog" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试类不变，打印结果为：1234567891011121314151617181920212223CurrentTime = 1446130273734Log before methodEnter HelloWorldImpl1.printHelloWorld()Log after methodCurrentTime = 1446130273735CurrentTime = 1446130273736Log before methodEnter HelloWorldImpl1.doPrint()Log after methodCurrentTime = 1446130273736CurrentTime = 1446130273736Log before methodEnter HelloWorldImpl2.printHelloWorld()Log after methodCurrentTime = 1446130273736CurrentTime = 1446130273737Log before methodEnter HelloWorldImpl2.doPrint()Log after methodCurrentTime = 1446130273737 要想让logHandler在timeHandler前使用有两个办法： （1）aspect里面有一个order属性，order属性的数字就是横切关注点的顺序 （2）把logHandler定义在timeHandler前面，Spring默认以aspect的定义顺序作为织入顺序 2、我只想织入接口中的某些方法 修改一下pointcut的expression就好了：12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"&gt; &lt;bean id="helloWorldImpl1" class="com.xrq.aop.HelloWorldImpl1" /&gt; &lt;bean id="helloWorldImpl2" class="com.xrq.aop.HelloWorldImpl2" /&gt; &lt;bean id="timeHandler" class="com.xrq.aop.TimeHandler" /&gt; &lt;bean id="logHandler" class="com.xrq.aop.LogHandler" /&gt; &lt;aop:config&gt; &lt;aop:aspect id="time" ref="timeHandler" order="1"&gt; &lt;aop:pointcut id="addTime" expression="execution(* com.xrq.aop.HelloWorld.print*(..))" /&gt; &lt;aop:before method="printTime" pointcut-ref="addTime" /&gt; &lt;aop:after method="printTime" pointcut-ref="addTime" /&gt; &lt;/aop:aspect&gt; &lt;aop:aspect id="log" ref="logHandler" order="2"&gt; &lt;aop:pointcut id="printLog" expression="execution(* com.xrq.aop.HelloWorld.do*(..))" /&gt; &lt;aop:before method="LogBefore" pointcut-ref="printLog" /&gt; &lt;aop:after method="LogAfter" pointcut-ref="printLog" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 可以看到expression字段，表示timeHandler只会织入HelloWorld接口print开头的方法，logHandler只会织入HelloWorld接口do开头的方法. 3、强制使用CGLIB生成代理 前面说过Spring使用动态代理或是CGLIB生成代理是有规则的，高版本的Spring会自动选择是使用动态代理还是CGLIB生成代理内容，当然我们也可以强制使用CGLIB生成代理，那就是里面有一个”proxy-target-class”属性，这个属性值如果被设置为true，那么基于类的代理将起作用，如果proxy-target-class被设置为false或者这个属性被省略，那么基于接口的代理将起作用 原理区别： java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。1231、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换 原文地址:点我]]></content>
      <categories>
        <category>Spring-AOP</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的Next主题侧边栏自定义修改]]></title>
    <url>%2F2017%2F05%2F17%2FHexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%2FHexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E4%BE%A7%E8%BE%B9%E6%A0%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[Next主题的强大我就不多说了。侧边栏的标题和网站title标题相同，导致不能自定义。然后我就想着两者能不能分开，本文仅仅探讨个人想法。 如图所示。原版左边2个框是全部获取的title值。但是如何自定义获取呢。就要改源码。 首先右击做自己的太阳举例点击检查，查看源码发现div标签和class命名 然后我们就是根据这个字符去主题下搜索。windows是默认只搜索文件名，所以要设置一下，打开计算机，选择工具，文件夹选项。 搜索完然后我们查找到在themes\next\layout\_partials\header.swig文件。 修改成我们想要的字段，当然我们也可以新建字段，自定义内容。目前本人博客主题是Pisces主题。如图是我修改后的样子。 修改原理都一样，剩下来的都请大家自己探寻把。]]></content>
      <categories>
        <category>Hexo 博客教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合体系总结]]></title>
    <url>%2F2017%2F05%2F05%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F%E3%80%90Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E3%80%91Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、Collection(单列集合)List 有序 可重复123ArrayList 底层是数组 查找快，增删慢 线程不安全，效率高LinkedList 底层是链表 查找慢，增删快Vector 底层是数组 查找快，增删慢 线程安全，效率低 Set 无序 不可重复1234567891011HashSet 底层是哈希表 如何保证元素的唯一性 重写元素的hashcode和equals方法 hashcode相同 判断equals方法 返回true 不填加 返回false 添加 hashcode不相同 直接添加 TreeSet 底层是二叉树 如何保证元素的唯一性和排序 1、自然排序(元素具备比较特性) ----实现Comparable接口 2、使用排序器(集合具备比较特性) ---- 实现Comparator接口 二、Map(双列集合) 数据结构只针对键有效1234567891011HashMap 底层是哈希表 如何保证键的唯一性 重写元素的hashcode和equals方法 hashcode相同 判断equals方法 返回true 不填加 返回false 添加 hashcode不相同 直接添加 TreeMap 底层是二叉树 如何保证键的唯一性和排序 1、自然排序(元素具备比较特性) ----实现Comparable接口 2、使用排序器(集合具备比较特性) ---- 实现Comparator接口 功能12345678Collection add(Object obj) remove(Object obj) contains(obj) size() iterator() List add(int index,Object obj) remove(int index) get(index) setSet Map put(key,value) remove(key) get(key) containsValue(value) containsKey(key) get(key) keySet() values() entrySet() 遍历12345678List 1、迭代器 使用迭代器遍历集合时，不能通过集合对象去修改集合元素 2、for循环 3、增强for循环 仅仅是遍历集合，任选一种， 如果要对集合元素进行操作，使用后面两种 跟集合索引相关的操作，使用for循环 123Set 1、迭代器 2、增强for循环 123Map 1、获取键集合，根据键找值 2、获取键值对集合，根据键值对对象获取键和值 怎么选择先看有没有对应关系(是否需要键值对) 123456789101112有 Map 是否需要对键排序 需要 TreeMap 不需要 HashMap 没有 Collection 是否要求元素唯一 是 Set 不是 List 是否对元素进行排序 增删多，查找少 LinkedList 是 TreeSet 增删少，查找多 ArrayList或者Vector 不是 HashSet 如果线程安全 Vector 不需要保证线程安全 ArrayList]]></content>
      <categories>
        <category>Java 基础知识</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven警告解决:Using platform encoding （UTF-8 actually）]]></title>
    <url>%2F2017%2F05%2F04%2FJava%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%2FMaven%E8%AD%A6%E5%91%8A%E8%A7%A3%E5%86%B3Using%20platform%20encoding%20(UTF-8%20actually)%2F</url>
    <content type="text"><![CDATA[执行Maven Install打包的时候，提示以下警告信息：1[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent! 解决方法：打开项目属性》Resources，按下图修改。 保存后重新执行Maven Install 发现警告依然存在，原来是理解错误错误了，应该修改Maven的配置文件中关于编码的配置 1&lt;encoding&gt;utf-8&lt;/encoding&gt;： 完整示例：pom.xml 12345678910&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt;&lt;/plugin&gt; 如果还是存在警告，则需要在中添加标签：12345&lt;properties&gt; &lt;project.build.sourceEncoding&gt; UTF-8 &lt;/project.build.sourceEncoding&gt;&lt;/properties&gt; 最终 Maven Install 警告就消失了。 本文作者： Scorpip_cc 本文链接： 原文博客地址 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！]]></content>
      <categories>
        <category>Java 报错解决</category>
      </categories>
      <tags>
        <tag>Java后台开发</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
</search>